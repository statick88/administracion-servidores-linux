---
title: "Unidad 1: Introducci√≥n a Sistemas Operativos"
description: "Fundamentos de sistemas operativos: qu√© son, componentes principales, funciones esenciales y su papel en la infraestructura tecnol√≥gica moderna"
author: "Diego Saavedra"
date: "2024-01-29"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: false
    highlight-style: github
bibliography: references.bib
biblio-style: apalike
---

# üéØ Introducci√≥n a Sistemas Operativos

## Introducci√≥n

Un **Sistema Operativo** es el software fundamental que controla todos los recursos de una computadora y gestiona las interacciones entre el usuario, aplicaciones y hardware. En Abacom, entender profundamente qu√© es un SO y c√≥mo funciona es cr√≠tico para administrar servidores, resolver problemas de infraestructura y tomar decisiones arquitect√≥nicas correctas.

**Tiempo de lectura:** ~20 minutos  
**Nivel:** Principiante  
**Requisitos previos:** Conceptos b√°sicos de computadoras

---

## üó∫Ô∏è En este tema aprender√°s

En esta unidad cubriremos:

1. **¬øQu√© es un Sistema Operativo?** - Definici√≥n, rol y responsabilidades

2. **Componentes Principales** - Kernel, shell, drivers y utilidades

3. **Funciones Esenciales** - Gesti√≥n de recursos, procesos y memoria

4. **Diferencias entre SOs** - Comparativa entre Windows, macOS y Linux

5. **Por qu√© existe Linux** - Historia, filosof√≠a y ventajas

---

## ¬øQu√© es un Sistema Operativo?

**Definici√≥n clara:**

Un Sistema Operativo (SO) es un programa especial que act√∫a como **intermediario entre el usuario y el hardware**. Su funci√≥n principal es gestionar todos los recursos de la computadora (memoria, procesador, disco duro, dispositivos perif√©ricos) y permitir que otros programas funcionen correctamente [@posix_2017].

::: {.callout-note}
## ¬øPor qu√© importa?

- **Impacto directo:** Sin un SO, no podr√≠as ejecutar ning√∫n programa. El SO es lo que permite que todo funcione.
- **En Abacom:** Necesitamos entender c√≥mo el SO gestiona servidores para optimizar rendimiento y resolver problemas.
- **Ventaja profesional:** Un administrador que entiende el SO puede diagnosticar 80% de problemas sin herramientas externas.

:::

---

## Kernel vs Shell

**Definici√≥n clara:**

Aunque a menudo se confunden, son dos cosas diferentes:

- **Kernel:** El n√∫cleo del SO. Controla directamente el hardware y gestiona procesos, memoria y dispositivos.
- **Shell:** La "interfaz" entre el usuario y el kernel. Es lo que ves en terminal - interpreta tus comandos y le dice al kernel qu√© hacer.

::: {.callout-warning}
## Punto importante

El kernel trabaja en "modo privilegiado" (ring 0), lo que significa tiene acceso total al hardware. Los programas normales corren en "modo usuario" (ring 3) con permisos limitados. Esta separaci√≥n es cr√≠tica para la seguridad.
:::

---

## üí° Ejemplos Pr√°cticos

::: {.panel-tabset}

### Ejemplo 1: Verifica tu SO

#### Linux

```bash
# Ver informaci√≥n del SO en Linux
$ uname -a
Linux servidor-abacom 5.15.0-89-generic #99-Ubuntu SMP Mon Oct 5 09:29:34 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux

# Informaci√≥n adicional
$ cat /etc/os-release | grep PRETTY_NAME
PRETTY_NAME="Ubuntu 22.04.4 LTS"
```

**Explicaci√≥n:**

- **uname -a**: Muestra nombre del kernel, versi√≥n y arquitectura
- En Linux: Kernel es "Linux 5.15.0" en arquitectura "x86_64" (64 bits)
- **Resultado**: Informaci√≥n t√©cnica para administraci√≥n de servidores

#### macOS

```bash
# Ver informaci√≥n del SO en macOS
$ uname -a
Darwin macbook-pro 23.3.0 Darwin Kernel Version 23.3.0 arm64

# Versi√≥n del sistema macOS
$ sw_vers
ProductName:    macOS
ProductVersion: 14.2.1
BuildVersion:   23C71
```

**Explicaci√≥n:**

- **uname -a**: Muestra "Darwin" (kernel de macOS) en arquitectura arm64 (Apple Silicon) o x86_64 (Intel)
- **sw_vers**: Muestra versi√≥n espec√≠fica de macOS instalado
- **Resultado**: macOS es basado en Unix, compatible con comandos Linux

#### Windows

```powershell
# Ver informaci√≥n del SO en Windows (PowerShell)
PS> systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
OS Name:                   Microsoft Windows 11 Professional
OS Version:                10.0.22621 Build 22621
System Type:               x64-based PC

# Alternativa m√°s detallada
PS> Get-ComputerInfo -Property osname, osversion, systemskufamily
```

**Explicaci√≥n:**

- **systeminfo**: Muestra informaci√≥n detallada del sistema
- **findstr**: Filtra solo l√≠neas espec√≠ficas (similar a grep en Linux)
- **Resultado**: Windows usa arquitectura x64 (equivalente a x86_64 en Linux)

---

### Ejemplo 2: Ver procesos del SO

#### Linux

```bash
# Listar procesos en ejecuci√≥n en Linux
$ ps aux | head -10
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  10960  5216 ?        Ss   10:23   0:01 /sbin/init
root         2  0.0  0.0      0     0 ?        S    10:23   0:00 [kthreadd]
systemd+   560  0.0  0.2  89456  3564 ?        Ss   10:23   0:00 /lib/systemd/systemd-resolved

# Ver solo procesos de tu usuario
$ ps ux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
diego     5432  0.0  0.5 234567 8912 pts/0    S+   14:35   0:00 bash
```

**C√≥mo funciona:**

- **ps aux**: Lista todos los procesos del sistema con detalles completos
- **PID**: Identificador √∫nico de proceso
- **%CPU / %MEM**: Porcentaje de CPU y memoria que usa
- **STAT**: Estado del proceso (Ss = running, S = sleeping)

#### macOS

```bash
# Listar procesos en macOS
$ ps aux | head -10
USER              PID  %CPU %MEM      VSZ      RSS   TT  STAT STARTED      TIME COMMAND
root                1   0.0  0.1  4348784   16564   ??  Ss   Wed01PM   0:32.54 /sbin/launchd
root               46   0.0  0.0  4484408    5232   ??  Ss   Wed01PM   0:16.32 /usr/sbin/syslogd
_windowserver     108   1.5  1.2  5672744  201456   ??  Ss   Wed01PM  15:24.32 /System/Library/PrivateFrameworks/SkyLight.framework/Versions/A/Resources/WindowServer

# Ver procesos m√°s legiblemente
$ top -l 1 -n 10
```

**C√≥mo funciona:**

- Similar a Linux pero con columnas ligeramente diferentes
- **STARTED**: Cu√°ndo se inici√≥ el proceso
- **WindowServer**: Proceso especial de macOS para gr√°ficos

#### Windows

```powershell
# Ver procesos en Windows (PowerShell)
PS> Get-Process | Select-Object Name, Id, CPU, Memory | Sort-Object Memory -Descending | Select-Object -First 10

Name                Id  CPU      Memory
----                --  ---      ------
svchost           1234   1.5   523264
explorer          5678   2.3   456789
chrome            9012   8.5   1234567
python            3456   0.1   234567

# Alternativa: usar tasklist
PS> tasklist /V | findstr "python"
```

**C√≥mo funciona:**

- **Get-Process**: Obtiene lista de procesos activos
- **Id**: Identificador √∫nico (equivalente a PID en Linux)
- **Memory**: Uso de memoria en bytes
- **tasklist**: Comando cl√°sico de Windows para listar procesos

---

### Ejemplo 3: Caso Real Abacom

#### Linux (Servidor de Producci√≥n)

```bash
# En un servidor Linux de Abacom, verificar recursos del sistema
$ free -h
              total        used        free      shared  buff/cache   available
Mem:           15.6G       3.2G       9.1G       256M       3.3G      12.0G
Swap:           4.0G       0.0B       4.0G

# Ver carga del servidor
$ uptime
 14:35:42 up 247 days, 3:42, 2 users, load average: 0.85, 0.92, 0.88

# Ver procesos principales de la aplicaci√≥n
$ ps aux | grep "python\|node\|java"
```

**Por qu√© lo usamos en Abacom:**

- Monitorear memoria disponible para aplicaciones cr√≠ticas
- Detectar si el servidor est√° bajo carga (load average)
- Uptime de 247 d√≠as = Excelente estabilidad
- Planificar upgrades de hardware si es necesario

#### macOS (M√°quina de Desarrollo)

```bash
# En una Mac de desarrollo de Abacom
$ memory_pressure
System memory pressure level: 2 (elevated)
Physical memory: 16GB

# Ver recursos del sistema
$ top -l 1 -stats cpu,mem -n 5

# Memoria disponible
$ vm_stat
```

**Por qu√© lo usamos en Abacom:**

- Verificar que tenemos suficiente RAM para Docker/VirtualBox
- Monitorear si las herramientas de desarrollo est√°n consumiendo demasiado
- Detectar memory leaks en aplicaciones

#### Windows (M√°quina de Administrador)

```powershell
# En Windows para administraci√≥n remota de Abacom
PS> Get-ComputerInfo -Property TotalPhysicalMemory, FreePhysicalMemory

TotalPhysicalMemory : 17179869184 (16 GB)
FreePhysicalMemory  : 8589934592 (8 GB)

# Ver procesos por memoria
PS> Get-Process | Sort-Object Memory -Descending | Select-Object -First 5

# Informaci√≥n del sistema
PS> systeminfo | findstr /C:"Processor" /C:"System Type" /C:"Total Physical Memory"
```

**Por qu√© lo usamos en Abacom:**

- Monitorear servidores remotos desde Windows
- Verificar que tengas suficiente RAM en tu m√°quina
- Automatizar tareas de administraci√≥n

:::

---

---

## üîß Componentes Principales del Sistema Operativo

### El Kernel - El Coraz√≥n

El kernel es la parte m√°s importante. Gestiona:

- **Procesos:** Ejecuta programas y los alterna entre CPU
- **Memoria:** Asigna RAM a cada proceso
- **Devices (Dispositivos):** Controla disco, red, impresoras, etc.
- **Interrupts (Interrupciones):** Responde a eventos urgentes

```bash
# Ver informaci√≥n del kernel en Linux
$ uname -r  # <1>
5.15.0-89-generic

# Ver m√≥dulos del kernel cargados
$ lsmod | head -10  # <2>
Module                  Size  Used by
overlay                81920  0
kvm_intel             323584  0
kvm                  1019904  1 kvm_intel
...
```

1. **uname -r** muestra la versi√≥n exacta del kernel de tu sistema

2. **lsmod** lista los m√≥dulos del kernel que est√°n actualmente cargados en memoria

El kernel Linux se actualiza para seguridad y rendimiento, pero rara vez requiere reinicio.

### Drivers - Los Traductores

Los drivers (controladores) permiten que el SO hable con el hardware espec√≠fico:

- **Video Driver:** Comunica con tu tarjeta gr√°fica
- **Network Driver:** Comunica con tu tarjeta de red
- **Storage Driver:** Comunica con disco duro/SSD

```bash
# Listar dispositivos reconocidos
$ lspci | grep -E "(Network|VGA|Audio)"  # <1>
00:02.0 VGA compatible controller: Intel Corporation UHD Graphics 630
00:1f.6 Ethernet controller: Intel Corporation Ethernet Connection

# Ver drivers cargados
$ lsmod | grep -i eth  # <2>
```

1. **lspci** lista todos los dispositivos PCI conectados al sistema, filtramos solo Network, VGA y Audio

2. **lsmod | grep -i eth** muestra solo los m√≥dulos de ethernet cargados en el kernel

Sin drivers correctos, el hardware no funciona.

### Shell - La Interfaz

El shell es lo que **t√∫ ves y usas**. Convierte tus comandos en √≥rdenes que el kernel entiende:

```bash
# Usando shell bash
$ ls -la /home  # <1>
total 28
drwxr-xr-x  3 root root 4096 Jan 29 14:22 .
drwxr-xr-x 23 root root 4096 Jan 29 14:22 ..
drwxr-xr-x  5 diego staff 160 Jan 29 14:22 diego

# El shell interpreta "ls -la /home" y le dice al kernel:  # <2>
# "Lee el directorio /home y muestra detalles"
```

1. **ls -la /home** lista todos los directorios en /home con detalles (permisos, due√±o, fecha, etc.)

2. El shell convierte este comando en instrucciones que el kernel entiende

Diferentes shells: **bash**, **zsh**, **sh**, **fish**.

---

## üîß Funciones Esenciales del Sistema Operativo

### Gesti√≥n de Procesos

El SO decide **qu√© programa corre y cu√°ndo**:

```bash
# Ver procesos en tiempo real
$ top -b -n 1 | head -20  # <1>

top - 14:40:15 up 247 days, 3:47,  2 users,  load average: 0.92, 0.91, 0.89
Tasks: 156 total,   1 running, 155 sleeping,   0 stopped,   0 zombie  # <2>
%Cpu(s):  3.2 us,  2.1 sy,  0.0 ni, 94.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st  # <3>
```

1. **top -b -n 1** ejecuta top en modo batch (sin interfaz interactiva) una sola vez

2. La l√≠nea "Tasks" muestra cu√°ntos procesos est√°n ejecut√°ndose (156 total, 1 corriendo, 155 dormidos)

3. La l√≠nea "%Cpu(s)" muestra el porcentaje de CPU usado en modo usuario (us), sistema (sy), inactivo (id), etc.

**C√≥mo funciona:**

1. El SO maneja un "planificador" (scheduler) que decides cu√°l proceso ejecutar

2. Si tienes un CPU de 4 n√∫cleos, puede ejecutar 4 cosas simult√°neamente

3. En paralelo, el SO cambia entre procesos muy r√°pidamente (time slicing)

4. Resultado: Parece que 100 programas corren "al mismo tiempo"

### Gesti√≥n de Memoria

El SO asigna RAM a cada proceso de forma segura:

```bash
# Ver uso de memoria
$ cat /proc/meminfo  # <1>
MemTotal:       16409912 kB    # RAM Total en el sistema  # <2>
MemFree:         9654832 kB    # RAM Disponible sin usar  # <3>
MemAvailable:   12506144 kB    # RAM que puede usar si es necesario  # <4>
```

1. **/proc/meminfo** es un archivo virtual que muestra informaci√≥n detallada de memoria del kernel

2. MemTotal es la cantidad total de RAM disponible

3. MemFree es RAM completamente sin usar (no incluye cach√©)

4. MemAvailable es RAM que el kernel puede liberar r√°pidamente si la necesita otra aplicaci√≥n
...
```

**Importancia:**

- Cada proceso cree que tiene acceso a toda la memoria (memoria virtual)
- El SO maneja la traducci√≥n real a direcciones f√≠sicas
- Si se acaba RAM, usa disco (swap) - mucho m√°s lento

### Gesti√≥n de Dispositivos

El SO es el "polic√≠a" que controla acceso a hardware:

```bash
# Ver dispositivos de almacenamiento
$ lsblk  # <1>
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT  # <2>
sda      8:0    0  500G  0 disk  # <3>
‚îú‚îÄsda1   8:1    0    1G  0 part /boot  # <4>
‚îú‚îÄsda2   8:2    0  499G  0 part /
sdb      8:16   0    2T  0 disk
‚îî‚îÄsdb1   8:17   0    2T  0 part /data
```

1. **lsblk** (block list) muestra todos los dispositivos de almacenamiento en forma de √°rbol

2. NAME: nombre del dispositivo, SIZE: tama√±o, TYPE: tipo (disk=disco, part=partici√≥n), MOUNTPOINT: d√≥nde est√° montado

3. **sda** es el primer disco duro (500 GB), identificado como 8:0 en el kernel

4. **sda1** y **sda2** son particiones (divisiones) del disco sda, la primera (1G) es /boot (donde arranca el SO)

El SO decide qu√© proceso puede acceder a qu√© dispositivo en qu√© momento.

### Gesti√≥n de Archivos

El SO organiza datos en carpetas y archivos:

```bash
# Ver sistema de archivos
$ df -h  # <1>
Filesystem      Size  Used Avail Use% Mounted on  # <2>
/dev/sda2       500G  120G  380G  24% /  # <3>
/dev/sdb1         2T  1.5T  500G  75% /data  # <4>
tmpfs           7.8G     0  7.8G   0% /dev/shm
```

1. **df -h** (disk free) muestra el espacio disponible en todos los sistemas de archivos montados (-h = human readable, en GB/TB)

2. Filesystem: dispositivo, Size: tama√±o total, Used: usado, Avail: disponible, Mounted on: d√≥nde est√° montado

3. **/dev/sda2** es la partici√≥n principal (/) con 500G total, 120G usados, 380G disponibles (24% ocupado)

4. **/dev/sdb1** es una segunda partici√≥n montada como /data, casi llena (75% usada, solo 500G disponibles)

El SO traduce "abre archivo.txt" en "busca en sector X del disco Y".

---

## ‚ö†Ô∏è Errores Comunes

### Confundir "No hay memoria" con "No hay espacio en disco"

::: {.callout-caution}
## S√≠ntoma que ver√°s

```
Cannot allocate memory
# O en aplicaciones:
java.lang.OutOfMemoryError: Java heap space
```

**Causa ra√≠z:** Se llen√≥ la RAM, no el disco. Estas son dos cosas diferentes.

**Soluci√≥n comprobada:**
```bash
# ‚ùå Forma INCORRECTA (buscar espacio en disco)
$ df -h  # <1>
Filesystem      Size  Used Avail
/               500G  100G  400G  ‚Üê A√∫n hay espacio!

# ‚úÖ Forma CORRECTA (revisar RAM)
$ free -h  # <2>
               total    used    free
Mem:          15.6G   14.8G   0.8G  ‚Üê ¬°RAM llena!
```

1. df -h** muestra espacio en disco (500G disponibles), as√≠ que el problema NO es falta de disco

2. **free -h** muestra RAM, y aqu√≠ est√° el problema: solo 0.8G de 15.6G disponibles, la RAM est√° casi llena

**Por qu√© funciona la soluci√≥n:**
El error es de RAM, no de disco. **df** ve espacio en disco, pero **free** muestra RAM agotada. Son dos sistemas diferentes del SO.
:::

### El sistema "se congela"

::: {.callout-warning}
**S√≠ntoma:** Todo se ralentiza o se detiene completamente  
**Causa:** Generalmente swapping excesivo (usando disco en lugar de RAM) o CPU sobrecargada  
**Soluci√≥n:**
```bash
# Verificar carga de CPU
$ uptime  # <1>
load average: 12.5, 11.2, 10.1  ‚Üê Si es > n√∫cleos CPU, est√° sobrecargado  # <2>

# Verificar swap (disco usado como memoria)
$ swapon -s  # <3>
Filename  Size  Used Priority
/dev/sda1 4000000 3900000 -1  ‚Üê Si Used es alto, es el problema  # <4>
```

1. **uptime** muestra cu√°nto tiempo lleva el sistema activo y el "load average" (promedio de procesos en cola)

2. Si load average (12.5, 11.2, 10.1) es mayor que los n√∫cleos CPU que tienes (ej: 4 n√∫cleos), el CPU est√° sobrecargado

3. **swapon -s** muestra si el sistema est√° usando swap (disco como RAM, mucho m√°s lento)

4. Si "Used" de swap es alto, significa que se llen√≥ la RAM y ahora est√° usando disco, causando ralentizaciones severas
:::

---

## üìä Mejores Pr√°cticas

::: {.callout-important}
## Patrones Recomendados

‚úÖ **HACER (Pr√°cticas Probadas):**

- Monitorear RAM disponible continuamente ‚Üí previene problemas antes
- Mantener kern√©l actualizado ‚Üí parches de seguridad
- Revisar procesos que consumen recursos ‚Üí identificar culpables

‚ùå **NO HACER (Antipatrones):**

- Ignorar alertas de memoria llena ‚Üí causa crashes
- Ejecutar procesos como **root** innecesariamente ‚Üí riesgo seguridad
- Llenar swap sin investigar ‚Üí enmascara problema real
:::

---

## üìã Tabla de Referencia R√°pida

| Comando | Prop√≥sito | Uso |
|---------|-----------|-----|
| uname -a` | Ver informaci√≥n del SO y kernel | Diagn√≥stico del sistema |
| `ps aux` | Listar todos los procesos | Monitoreo de aplicaciones |
| **top** o **htop** | Monitor en tiempo real | Diagn√≥stico de rendimiento |
| `free -h` | Ver uso de memoria RAM | Verificar disponibilidad memoria |
| `df -h` | Ver espacio en disco | Monitorear particiones |
| **lsmod** | Listar m√≥dulos del kernel | Diagn√≥stico de drivers |

---

## üéì Quiz: Verifica tu Comprensi√≥n

::: {.callout-note}
## Antes de continuar

Responde estas preguntas para verificar que comprendiste los conceptos clave. 
Si tienes dudas, vuelve a las secciones anteriores.
:::

### ¬øCu√°l es la diferencia entre Kernel y Shell?

<details>
<summary>üìñ Ver respuesta</summary>

**Kernel** es el software central que controla directamente el hardware. **Shell** es la interfaz que usa el usuario para comunicarse con el kernel.

**Ejemplo diferenciador:**
```bash
# El kernel hace esto:
# - Gestiona CPU, memoria, disco
# - Maneja interrupciones de hardware
# - Asigna recursos a procesos

# El shell hace esto:
$ ls -la /home
# ‚Üë Shell interpreta esto
# ‚Üì Le dice al kernel: "Lee directorio /home"
```

**Por qu√© es importante la diferencia:**
El kernel es invisible - nunca lo usas directamente. El shell es lo que ves. Si entiendes esta separaci√≥n, entiendes c√≥mo funciona todo.

</details>

### ¬øCu√°l es el comando para ver si tu RAM est√° llena?

<details>
<summary>üí° Ver respuesta</summary>

```bash
$ free -h
```

**Explicaci√≥n t√©cnica:** **free** muestra memoria RAM. **-h** significa "human-readable" (formato legible). Este comando le dice al kernel: "dame un reporte de memoria".

**Validaci√≥n:** Si ejecutas esto, deber√≠as ver:
```
             total    used    free   shared  buff/cache available
Mem:         15.6G   3.2G    9.1G     256M      3.3G      12.0G
```

Si **free** es muy peque√±o o **used** es muy grande, la RAM est√° llena.

</details>

### ¬øEn qu√© escenario revisar√≠as `free -h` en lugar de `df -h`?

<details>
  <summary>üéØ Ver respuesta</summary>

  Usar√≠as `free -h` cuando una **aplicaci√≥n reporta error de memoria**, no cuando te falta espacio en disco.

  **Ejemplo pr√°ctico:**

  - ‚úÖ Usar `free -h` cuando: Java reporta "OutOfMemoryError" o aplicaci√≥n se crashes con "Cannot allocate memory"
  - ‚ùå No usar `free -h` cuando: El disco muestra "100% full" o error de "No space left on device"

  **Caso Abacom:** En nuestros servidores, cuando una base de datos se ralentiza, PRIMERO revisamos `free -h`. Si RAM est√° bien, LUEGO revisamos `df -h` y otros factores.
  </summary>
</details>

---

## üë®‚Äçüíª Pr√°ctica Guiada con el Instructor

### Identificar tu Sistema Operativo

**Objetivo:** Ejecutar comandos b√°sicos para entender qu√© SO tienes y c√≥mo funciona.

**Pasos:**

1. Abrir una terminal (macOS/Linux) o PowerShell (Windows)

2. Ejecutar comandos para obtener informaci√≥n

3. Interpretar los resultados

**Instrucciones:**
```bash
# Paso 1: Ver informaci√≥n del SO
$ uname -a  # <1>
# Deber√≠as ver: informaci√≥n del kernel, versi√≥n, arquitectura

# Paso 2: Ver los primeros procesos del sistema
$ ps aux | head -10  # <2>
# Deber√≠as ver: procesos del sistema operativo en ejecuci√≥n

# Paso 3: Ver memoria disponible
$ free -h  # <3>
# Deber√≠as ver: cu√°nta RAM tienes y cu√°nta est√° disponible
```

1. **uname -a** (all) muestra toda la informaci√≥n del sistema: nombre kernel, versi√≥n, m√°quina, procesador

2. **ps aux** lista todos los procesos en ejecuci√≥n, `| head -10` muestra solo los primeros 10

3. **free -h** (human readable) muestra RAM total, usada, libre en formato legible (GB)

**Verificaci√≥n:**

- ‚úì Ves el nombre del kernel (Linux, Darwin para macOS, etc.)
- ‚úì Ves una lista de procesos numerados
- ‚úì Ves n√∫meros de memoria (Mem: XXG)

### Monitorear Recursos en Tiempo Real

**Objetivo:** Observar c√≥mo el SO gestiona recursos mientras ejecutas comandos.

**Pasos:**

1. Abrir **top** o **htop** para ver monitoreo

2. Notar c√≥mo cambian los procesos

3. Ejecutar un comando que consume recursos

**Instrucciones:**
```bash
# Ejecuta esto en una terminal
$ top

# En otra terminal, ejecuta un comando que consume recursos
$ yes > /dev/null  # Genera CPU load

# Vuelve a la terminal con top
# Ver√°s que el proceso "yes" aparece
# NOTA: presiona 'q' para salir de top
```

**Verificaci√≥n:**

- ‚úì Ves el proceso "yes" en la lista de top
- ‚úì Ves que %CPU es alto para ese proceso
- ‚úì El cambio ocurre en tiempo real

### Ejercicio Avanzado - Investigar Problema de Rendimiento

**Objetivo:** Simular un diagn√≥stico real de Abacom.

**Instrucciones:**
```bash
# Escenario: El servidor est√° lento
# Paso 1: Ver carga del sistema
$ uptime
# Resultado esperado: load average values

# Paso 2: Ver si es por memoria
$ free -h
# Resultado esperado: see available memory

# Paso 3: Ver qu√© procesos consumen CPU
$ top -b -n 1 | sort -k 3 -nr | head -5
# Resultado esperado: top 5 procesos por CPU

# Paso 4: Conclusi√≥n
# "El servidor est√° lento porque [memoria/CPU/disco]"
```

**Verificaci√≥n:**

- ‚úì Entiendes qu√© significan los n√∫meros
- ‚úì Puedes identificar el culpable (memoria, CPU, disco)
- ‚úì Sabes qu√© pasos seguir para resolver

---

## üß™ Laboratorio de Pr√°ctica Integrado

**Duraci√≥n:** 60-90 minutos  
**Dificultad:** Intermedio  
**Objetivo General:** Dominar diagn√≥stico b√°sico de sistemas operativos

### Fase 1: Preparaci√≥n del Entorno (15 min)

Crea un espacio de trabajo para tus pr√°cticas:

```bash
# Crear directorios de trabajo
$ mkdir -p ~/laboratorio-so/resultados
$ cd ~/laboratorio-so

# Crear archivo de notas
$ touch diagnostico.txt
```

### Fase 2: Informaci√≥n del Sistema (20 min)

**Tarea:** Recopilar informaci√≥n completa del SO

```bash
# Archivo: resultados/info-so.txt
# Ejecuta estos comandos y guarda output:

$ uname -a > resultados/info-so.txt
$ cat /etc/os-release >> resultados/info-so.txt
$ lsb_release -a >> resultados/info-so.txt

# Verificar que se guard√≥
$ cat resultados/info-so.txt
# Deber√≠as ver toda la informaci√≥n del SO
```

**Ejercicio:**

1. Ejecuta cada comando

2. Guarda los resultados en el archivo

3. Interpreta: ¬øQu√© versi√≥n de kernel tienes? ¬ø32 o 64 bits?

### Fase 3: Monitoreo de Recursos (20 min)

**Tarea:** Registrar estado de recursos

```bash
# Archivo: resultados/recursos.txt
# Ejecuta estos comandos:

$ free -h > resultados/recursos.txt
$ df -h >> resultados/recursos.txt
$ top -b -n 1 | head -20 >> resultados/recursos.txt

# Verificar
$ cat resultados/recursos.txt
```

**Ejercicio:**

1. ¬øCu√°nta RAM tienes?

2. ¬øCu√°nta RAM est√° disponible?

3. ¬øCu√°l es el proceso que m√°s CPU consume?

### Fase 4: An√°lisis de Procesos (20 min)

**Tarea:** Identificar procesos cr√≠ticos

```bash
# Archivo: resultados/procesos.txt
# Listar procesos ordenados por CPU

$ ps aux --sort=-%cpu | head -10 > resultados/procesos.txt

# Listar procesos ordenados por memoria
$ ps aux --sort=-%mem | head -10 >> resultados/procesos.txt

# Contar total de procesos
$ ps aux | wc -l >> resultados/procesos.txt
```

**Ejercicio:**

1. ¬øCu√°l es el proceso que m√°s CPU consume?

2. ¬øCu√°l es el proceso que m√°s memoria consume?

3. ¬øCu√°ntos procesos totales hay en ejecuci√≥n?

### Fase 5: Proyecto Integrador - Diagn√≥stico Real (15 min)

**Desaf√≠o Final:** Crea un resumen de diagn√≥stico como un administrador real.

**Escenario:** En Abacom, el servidor est√° reportando bajo rendimiento. Necesitas diagnosticar.

**Soluci√≥n esperada:**
```bash
# Pasos para resolver
$ cat > resultados/diagnostico-final.txt << 'EOF'
=== DIAGN√ìSTICO DEL SISTEMA ===

1. SISTEMA OPERATIVO:
[Informaci√≥n del OS aqu√≠ - ejecuta: uname -a]

2. MEMORIA RAM:
Total: [n√∫mero de free -h]
Disponible: [n√∫mero de free -h]
Uso: [porcentaje]

3. ESPACIO EN DISCO:
[Ejecuta: df -h]

4. CARGA DEL SISTEMA:
[Ejecuta: uptime]

5. PROCESO PRINCIPAL CONSUMIENDO CPU:
[Ejecuta: ps aux --sort=-%cpu | head -2]

6. CONCLUSI√ìN:
El problema es [RAM / CPU / DISCO / OTRO] porque...
EOF

# Validaci√≥n Final
$ cat resultados/diagnostico-final.txt
```

**Validaci√≥n Final:**
```bash
# Verifica que completaste todo
$ ls -la ~/laboratorio-so/resultados/
# Deber√≠as ver: info-so.txt, recursos.txt, procesos.txt, diagnostico-final.txt
```

### Verificaci√≥n del Laboratorio

Marca cuando completes cada punto:

- [ ] Entorno preparado sin errores
- [ ] Informaci√≥n del SO recopilada correctamente
- [ ] Recursos monitoreados exitosamente
- [ ] Procesos identificados y analizados
- [ ] Diagn√≥stico final completado
- [ ] Resultado guardado en archivos

---

## üìö Recursos Adicionales

### Documentaci√≥n Oficial

- **[Linux man-pages - standards(7)](https://man7.org/linux/man-pages/man7/standards.7.html)**
  - Secci√≥n relevante: Est√°ndares POSIX y Unix
  - Por qu√© es √∫til: Entender los est√°ndares que cumple Linux

- **[Ubuntu Server Documentation](https://ubuntu.com/server/docs)**
  - Secci√≥n relevante: System fundamentals
  - Por qu√© es √∫til: Documentaci√≥n oficial de Ubuntu

### Tutoriales Complementarios

- **[Linux Foundation - The Linux Foundation](https://www.linuxfoundation.org/)**
  - Duraci√≥n: Varies
  - Cubre: Conceptos fundamentales de Linux

- **[Brendan Gregg - Systems Performance](http://www.brendangregg.com/systems-performance-2nd-edition-book.html)**
  - Duraci√≥n: Book (500+ pages)
  - Cubre: Diagn√≥stico avanzado de sistemas

### Comunidades y Foros

- **[Stack Overflow - Linux Tag](https://stackoverflow.com/questions/tagged/linux)**
  - Para: Preguntas t√©cnicas espec√≠ficas
  - C√≥mo usar: Busca tu pregunta o crea una nueva

- **[r/linux - Reddit](https://www.reddit.com/r/linux/)**
  - Para: Discusiones generales y noticias
  - C√≥mo usar: Community muy activa y receptiva

---

## ‚ùì Preguntas Frecuentes

**P: ¬øNecesito memorizar todos los comandos?**

R: No. Lo importante es entender QU√â hace cada comando. Con tiempo, memorizar√°s los m√°s comunes. Siempre puedes usar **man** (manual) para recordar sintaxis.

```bash
# Ver manual de cualquier comando
$ man free
$ man ps
$ man df
```

**P: ¬øPor qu√© macOS es diferente a Linux si ambos son Unix?**

R: Ambos siguen est√°ndares POSIX, pero tienen diferencias:

- macOS usa kernel XNU (derivado de BSD y Mach)
- Linux usa kernel Linux (de Linus Torvalds)
- Comandos b√°sicos son similares, pero algunos flags difieren

```bash
# En Linux
$ free -h

# En macOS (no existe 'free', usar esto)
$ vm_stat
# O instalar: brew install gnu-coreutils
```

**P: ¬øC√≥mo aplico esto en Abacom?**

R: En nuestro caso, usamos estos comandos diariamente:

- **top** o **htop** cuando reportan problemas de rendimiento
- `free -h` para verificar si falta RAM
- `df -h` para monitorear espacio en disco
- `ps aux` para encontrar procesos problem√°ticos

```bash
$ # Diagn√≥stico r√°pido de servidor Abacom
$ uptime && free -h && df -h && top -b -n 1 | head -20
```

---

## üéØ Resumen

::: {.callout-tip}
## Lo m√°s importante (3 puntos clave)

1. **Sistema Operativo = Intermediario entre usuario y hardware** ‚Üí Sin SO, no funciona nada. Todo pasa a trav√©s del SO.

2. **Kernel vs Shell** ‚Üí Kernel gestiona hardware (invisible), Shell es la interfaz (lo que ves).

3. **Diagn√≥stico de problemas** ‚Üí Usa `free -h` para memoria, `df -h` para disco, **top** para CPU.

**Recuerda:** Estos conceptos ser√°n la base para entender administraci√≥n avanzada de servidores.
:::

### Checklist de Competencias Alcanzadas

- ‚úÖ Entiendo qu√© es un Sistema Operativo y por qu√© es cr√≠tico
- ‚úÖ Puedo distinguir entre Kernel, Shell y Drivers
- ‚úÖ Reconozco errores comunes (RAM llena vs disco lleno)
- ‚úÖ Puedo usar comandos b√°sicos para diagnosticar problemas
- ‚úÖ Estoy listo para aprender Linux espec√≠ficamente

### Pr√≥ximos Pasos

::: {.callout-note}
üîú **Siguiente tema:** [Historia y Evoluci√≥n de Linux](2_historia_linux.html)  
üìã **Laboratorio siguiente:** Instalaci√≥n de Ubuntu 22.04 LTS  
‚è±Ô∏è **Tiempo recomendado:** 2 horas de lectura + 3 horas de pr√°ctica
:::

---

## üìû Soporte

::: {.callout-important}
## ¬øTienes dudas sobre este tema?

- üí¨ **Preguntas t√©cnicas:** Abre un issue en [GitHub Issues]
- üêõ **Errores no cubiertos:** Reporta en el repositorio
- üí° **Sugerencias para mejorar:** Env√≠a feedback a diego@abacom.cl
- üîó **Recursos adicionales:** Disponibles en la secci√≥n [Recursos Adicionales](#recursos-adicionales)
:::

---

**√öltima actualizaci√≥n:** 2026-01-29  
**Versi√≥n:** 1.0  
**Estado:** ‚úÖ Completo y validado contra fuentes oficiales

::: {.callout-note}
## Acerca de las fuentes

Todo el contenido de este m√≥dulo ha sido verificado contra:

- Est√°ndares POSIX.1-2017 y IEEE 1003.1
- Documentaci√≥n oficial de The Linux Foundation
- Man-pages oficiales de Linux

Las fuentes espec√≠ficas se encuentran en [Recursos Adicionales](#recursos-adicionales).
:::

---

## üìù Quiz: Introducci√≥n a Sistemas Operativos

```{quizdown}
---
shuffleAnswers: true
---

## ¬øCu√°l es la funci√≥n principal de un Sistema Operativo?

- [ ] Escribir programas
- [x] Gestionar recursos del hardware y proporcionar interfaz al usuario
- [ ] Almacenar archivos
- [ ] Conectarse a internet

## ¬øCu√°les son los tres componentes principales de un SO?

- [x] Kernel, Shell, y Utilidades/Aplicaciones
- [ ] CPU, Disco duro, Memoria
- [ ] Windows, Linux, Mac
- [ ] navegador, Editor de texto, Reproductor multimedia

## ¬øQu√© es un Kernel?

- [ ] Una aplicaci√≥n para usuarios
- [x] El n√∫cleo del SO que gestiona hardware y recursos
- [ ] El sistema de archivos
- [ ] Un tipo de procesador

## ¬øCu√°l es la funci√≥n del Shell?

- [ ] Proteger el hardware
- [ ] Almacenar datos
- [x] Proporcionar interfaz entre usuario y kernel
- [ ] Crear redes

## ¬øQu√© es un SO Monousuario?

- [x] SO que permite un solo usuario a la vez
- [ ] SO para una sola m√°quina
- [ ] SO sin contrase√±a
- [ ] SO muy b√°sico

## ¬øCu√°l es un ejemplo de SO Multiusuario?

- [ ] DOS
- [x] Linux
- [ ] Windows 95
- [ ] FreeDOS

## ¬øQu√© es Multitarea?

- [ ] Usar varios programas secuencialmente
- [x] Ejecutar varios programas simult√°neamente
- [ ] Cambiar de usuario r√°pidamente
- [ ] Trabajar en varios archivos

## ¬øQu√© caracter√≠stica define un SO de Tiempo Real?

- [ ] Velocidad extrema
- [x] Respuesta garantizada en tiempo espec√≠fico
- [ ] Interfaz gr√°fica
- [ ] Soporte multimedia

## ¬øQu√© es un SO embebido?

- [ ] SO que se esconde
- [x] SO optimizado para dispositivos con recursos limitados
- [ ] SO para servidores
- [ ] SO experimental

## Ejemplos de SO embebidos incluyen:

- [ ] Linux Desktop, Windows
- [x] Android, iOS, firmware de electrodom√©sticos
- [ ] macOS, Windows Server
- [ ] Todos los anteriores

## ¬øCu√°l es la diferencia entre Hardware y Software?

- [x] Hardware = componentes f√≠sicos, Software = programas e instrucciones
- [ ] Son lo mismo
- [ ] Hardware es m√°s importante
- [ ] Software es m√°s r√°pido

## ¬øQu√© es un archivo en un SO?

- [ ] Un documento impreso
- [x] Colecci√≥n de datos almacenados con un nombre √∫nico
- [ ] Un tipo de malware
- [ ] Una carpeta

## ¬øCu√°l es la funci√≥n del Gestor de Archivos?

- [ ] Proteger contra virus
- [x] Organizar y permitir acceso a archivos del disco
- [ ] Comprimir archivos autom√°ticamente
- [ ] Respaldar datos

## ¬øQu√© es el Boot o Arranque del SO?

- [ ] Apagar la computadora
- [ ] Iniciar un programa
- [x] Cargar el SO en memoria cuando se enciende la m√°quina
- [ ] Reiniciar el sistema

## ¬øCu√°l es la ventaja de usar particiones en un disco?

- [ ] Hacer el disco m√°s r√°pido
- [x] Organizar datos, instalar m√∫ltiples SOs, aislar fallos
- [ ] Aumentar espacio disponible
- [ ] Proteger contra virus

## ¬øQu√© es BIOS?

- [ ] Un programa antivirus
- [x] Firmware que inicia el hardware antes de cargar el SO
- [ ] Un tipo de sistema de archivos
- [ ] Un navegador web

## ¬øCu√°l es la funci√≥n del Gestor de Procesos?

- [ ] Escribir documentos
- [x] Asignar recursos CPU a programas en ejecuci√≥n
- [ ] Proteger archivos
- [ ] Crear conexiones de red

## ¬øQu√© es la Memoria Virtual?

- [ ] Memoria que no existe
- [x] Uso de disco duro para simular RAM adicional
- [ ] Memoria del navegador
- [ ] Almacenamiento en la nube

## ¬øCu√°l es la diferencia entre Memoria RAM y Disco Duro?

- [x] RAM es r√°pida pero temporal, Disco es lento pero permanente
- [ ] Son iguales
- [ ] RAM es permanente
- [ ] Disco duro es m√°s r√°pido

## ¬øCu√°l es una funci√≥n de Seguridad en un SO?

- [ ] Eliminar archivos autom√°ticamente
- [x] Control de acceso, autenticaci√≥n, gesti√≥n de permisos
- [ ] Comprimir todos los datos
- [ ] Conectar a internet autom√°ticamente
```

---

